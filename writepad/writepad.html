<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drawing App with Background Images</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        #canvasContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #guideCanvas,
        #drawingCanvas {
            position: absolute;
            top: 0;
            left: 0;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
        }

        #controls {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 10;
        }

        button,
        select {
            padding: 10px 20px;
            font-size: 16px;
            margin: 5px;
            cursor: pointer;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-color: #ffffff;
            border: 1px solid #cccccc;
            border-radius: 4px;
        }
    </style>
</head>

<body>
    <div id="controls">
        <button id="startSessionBtn">Start Session</button>
        <button id="nextBtn" disabled>Next</button>
        <select id="imageSelector" disabled>
            <option value="">Select an Image</option>
        </select>
        <select id="sizeSelector">
            <option value="120">Size 4 (Very Large)</option>
            <option value="70" selected>Size 3 (Large)</option>
            <option value="40">Size 2 (Medium)</option>
            <option value="20">Size 1 (Small)</option>
        </select>
        <button id="exportSessionBtn" disabled>Export Session</button>
    </div>
    <div id="canvasContainer">
        <canvas id="guideCanvas"></canvas>
        <canvas id="drawingCanvas"></canvas>
    </div>

    <script>
        // Session management
        let sessionActive = false;
        let sessionDrawings = {
            timestamp: null,
            drawings: []
        };

        const guideCanvas = document.getElementById('guideCanvas');
        const drawingCanvas = document.getElementById('drawingCanvas');
        const guideCtx = guideCanvas.getContext('2d');
        const drawingCtx = drawingCanvas.getContext('2d');
        const imageSelector = document.getElementById('imageSelector');
        const startSessionBtn = document.getElementById('startSessionBtn');
        const exportSessionBtn = document.getElementById('exportSessionBtn');
        const sizeSelector = document.getElementById('sizeSelector');
        const nextBtn = document.getElementById('nextBtn');

        // Set canvas sizes
        function resizeCanvases() {
            guideCanvas.width = window.innerWidth;
            guideCanvas.height = window.innerHeight;
            drawingCanvas.width = window.innerWidth;
            drawingCanvas.height = window.innerHeight;
        }
        resizeCanvases();

        let drawing = false;
        let lastX = 0, lastY = 0;

        function startDrawing(e) {
            drawing = true;
            const { x, y } = getPos(e);
            lastX = x;
            lastY = y;
        }

        function draw(e) {
            if (!drawing) return;
            const { x, y } = getPos(e);

            drawingCtx.beginPath();
            drawingCtx.moveTo(lastX, lastY);
            drawingCtx.lineTo(x, y);
            drawingCtx.strokeStyle = '#000';
            drawingCtx.lineWidth = 2;
            drawingCtx.lineCap = 'round';
            drawingCtx.stroke();

            lastX = x;
            lastY = y;
        }

        function stopDrawing() {
            drawing = false;
        }

        function getPos(e) {
            const rect = drawingCanvas.getBoundingClientRect();
            if (e.touches) {
                const touch = e.touches[0] || e.changedTouches[0];
                return {
                    x: touch.clientX - rect.left,
                    y: touch.clientY - rect.top
                };
            } else {
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }
        }

        // Drawing event listeners (now on drawingCanvas)
        drawingCanvas.addEventListener('touchstart', startDrawing);
        drawingCanvas.addEventListener('touchmove', draw);
        drawingCanvas.addEventListener('touchend', stopDrawing);
        drawingCanvas.addEventListener('mousedown', startDrawing);
        drawingCanvas.addEventListener('mousemove', draw);
        drawingCanvas.addEventListener('mouseup', stopDrawing);
        drawingCanvas.addEventListener('mouseout', stopDrawing);

        let currentIndex = 0;
        const imageOptions = [];

        // Load and draw guide images on guideCanvas only
        imageSelector.addEventListener('change', (e) => {
            const imageUrl = e.target.value;
            if (imageUrl) {
                const img = new Image();
                img.src = imageUrl;
                img.onload = () => {
                    guideCtx.clearRect(0, 0, guideCanvas.width, guideCanvas.height);

                    const imgWidth = parseInt(sizeSelector.value);
                    const imgHeight = (img.height / img.width) * imgWidth;
                    const spacing = imgWidth * 0.5;
                    const startX = 50;
                    const y = (guideCanvas.height - imgHeight) / 2;

                    // Draw guidelines on guideCanvas
                    guideCtx.beginPath();
                    guideCtx.moveTo(0, y + imgHeight * 0.9);
                    guideCtx.lineTo(guideCanvas.width, y + imgHeight * 0.9);
                    guideCtx.moveTo(0, y + imgHeight * 0.4);
                    guideCtx.lineTo(guideCanvas.width, y + imgHeight * 0.4);
                    guideCtx.strokeStyle = 'grey';
                    guideCtx.lineWidth = 1;
                    guideCtx.stroke();

                    // Draw guide images with decreasing opacity
                    for (let i = 0; i < 15; i++) {
                        const x = startX + (imgWidth + spacing) * i;
                        const opacity = Math.max(0.4 - (0.04 * i), 0.1);
                        guideCtx.globalAlpha = opacity;
                        guideCtx.drawImage(img, x, y, imgWidth, imgHeight);
                    }
                    guideCtx.globalAlpha = 1;
                };
            }
        });

        // Replace export button with session export
        exportSessionBtn.addEventListener('click', async () => {
            if (!sessionActive || sessionDrawings.drawings.length === 0) return;

            // Save the current drawing before export
            saveCurrentDrawing();

            // Create metadata structure
            const trainingData = {
                sessionInfo: {
                    timestamp: sessionDrawings.timestamp,
                    canvasWidth: drawingCanvas.width,
                    canvasHeight: drawingCanvas.height,
                    letterWidth: parseInt(sizeSelector.value),
                    letterHeight: parseInt(sizeSelector.value) * 1.5,
                    spacing: parseInt(sizeSelector.value) * 0.5,
                    baselineY: (drawingCanvas.height - parseInt(sizeSelector.value)) / 2 +
                        (parseInt(sizeSelector.value) * 0.9),
                    midlineY: (drawingCanvas.height - parseInt(sizeSelector.value)) / 2 +
                        (parseInt(sizeSelector.value) * 0.4),
                    guideImageScale: parseInt(sizeSelector.value) / 120
                },
                samples: []
            };

            // Create a new ZIP file
            const zip = new JSZip();

            // Create a folder for the images
            const imagesFolder = zip.folder("images");

            // Add each drawing to the zip and metadata
            for (let i = 0; i < sessionDrawings.drawings.length; i++) {
                const drawing = sessionDrawings.drawings[i];
                const timestamp = drawing.metadata.timestamp.replace(/[:.]/g, '');
                const filename = `${drawing.metadata.label}_${timestamp}_${drawing.metadata.position}.png`;

                // Add to metadata
                trainingData.samples.push({
                    filename: `images/${filename}`,
                    ...drawing.metadata
                });

                // Convert base64 to blob and add to zip
                const base64Data = drawing.imageData.replace(/^data:image\/png;base64,/, "");
                imagesFolder.file(filename, base64Data, { base64: true });
            }

            // Add metadata to zip
            zip.file("metadata.json", JSON.stringify(trainingData, null, 2));

            // Generate the zip file
            const zipBlob = await zip.generateAsync({ type: "blob" });

            // Create download link for the zip
            const zipUrl = URL.createObjectURL(zipBlob);
            const link = document.createElement('a');
            link.href = zipUrl;
            link.download = `training_data_${sessionDrawings.timestamp}.zip`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(zipUrl);

            // Reset session
            sessionActive = false;
            sessionDrawings = {
                timestamp: null,
                drawings: []
            };
            startSessionBtn.disabled = false;
            nextBtn.disabled = true;
            imageSelector.disabled = true;
            exportSessionBtn.disabled = true;
            drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
        });


        // Helper function to calculate pixel density (ratio of non-transparent pixels)
        function calculatePixelDensity(imageData) {
            let nonTransparentPixels = 0;
            for (let i = 3; i < imageData.data.length; i += 4) {
                if (imageData.data[i] > 0) nonTransparentPixels++;
            }
            return nonTransparentPixels / (imageData.width * imageData.height);
        }

        // Helper function to calculate stroke coverage (distribution of strokes)
        function calculateStrokeCoverage(imageData) {
            const thirds = { top: 0, middle: 0, bottom: 0 };
            const thirdHeight = imageData.height / 3;

            for (let y = 0; y < imageData.height; y++) {
                for (let x = 0; x < imageData.width; x++) {
                    const idx = (y * imageData.width + x) * 4 + 3;
                    if (imageData.data[idx] > 0) {
                        if (y < thirdHeight) thirds.top++;
                        else if (y < thirdHeight * 2) thirds.middle++;
                        else thirds.bottom++;
                    }
                }
            }

            const total = thirds.top + thirds.middle + thirds.bottom;
            if (total === 0) return thirds;

            return {
                top: thirds.top / total,
                middle: thirds.middle / total,
                bottom: thirds.bottom / total
            };
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            const drawingContent = drawingCtx.getImageData(0, 0, drawingCanvas.width, drawingCanvas.height);
            resizeCanvases();
            drawingCtx.putImageData(drawingContent, 0, 0);
            imageSelector.dispatchEvent(new Event('change')); // Redraw guides
        });

        // Session control functions
        function startSession() {
            sessionActive = true;
            sessionDrawings = {
                timestamp: new Date().toISOString().replace(/[:.]/g, '-'),
                drawings: []
            };

            // Enable controls
            startSessionBtn.disabled = true;
            nextBtn.disabled = false;
            imageSelector.disabled = false;
            exportSessionBtn.disabled = false;

            // Clear the canvas
            drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);

            // Select first image
            if (imageOptions.length > 0) {
                currentIndex = 0;
                imageSelector.value = imageOptions[0];
                imageSelector.dispatchEvent(new Event('change'));
            }
        }

        function saveCurrentDrawing() {
            const imgWidth = parseInt(sizeSelector.value);
            const spacing = imgWidth * 0.5;
            const startX = 50;
            const mainY = (drawingCanvas.height - imgWidth) / 2;

            // Create temp canvas for each letter area
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = imgWidth;
            tempCanvas.height = imgWidth * 1.5;

            // Get the current letter being traced
            const currentOption = imageSelector.selectedOptions[0];
            const label = currentOption.textContent;

            // Save each non-empty drawing area
            for (let i = 0; i < 15; i++) {
                tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);

                const sourceX = startX + (imgWidth + spacing) * i;
                const sourceY = mainY - (imgWidth * 0.5);

                // Copy just the drawing canvas content
                tempCtx.drawImage(
                    drawingCanvas,
                    sourceX, sourceY, imgWidth, imgWidth * 1.5,
                    0, 0, imgWidth, imgWidth * 1.5
                );

                // Check if there's any content
                const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                const hasContent = Array.from(imageData.data).some((value, index) =>
                    index % 4 === 3 && value > 0
                );

                if (hasContent) {
                    const opacity = Math.max(0.4 - (0.04 * i), 0.1);

                    sessionDrawings.drawings.push({
                        imageData: tempCanvas.toDataURL('image/png'),
                        metadata: {
                            label: label,
                            position: i + 1,
                            guideOpacity: opacity,
                            timestamp: new Date().toISOString(),
                            pixelDensity: calculatePixelDensity(imageData),
                            strokeCoverage: calculateStrokeCoverage(imageData)
                        }
                    });
                }
            }
        }

        // Load initial image options
        fetch('letters.json')
            .then(response => response.json())
            .then(data => {
                const images = data.lowercase;
                for (const key in images) {
                    const imageUrl = `letter_images/${encodeURIComponent(images[key])}`;
                    imageOptions.push(imageUrl);

                    const option = document.createElement('option');
                    option.value = imageUrl;
                    option.textContent = key;
                    imageSelector.appendChild(option);
                }

                if (imageOptions.length > 0) {
                    imageSelector.value = imageOptions[0];
                    imageSelector.dispatchEvent(new Event('change'));
                }
            })
            .catch(error => console.error('Error loading dataset:', error));

        // Session control event listeners
        startSessionBtn.addEventListener('click', startSession);

        // Modify next button behavior
        nextBtn.addEventListener('click', () => {
            if (sessionActive) {
                saveCurrentDrawing();
                currentIndex = (currentIndex + 1) % imageOptions.length;
                imageSelector.value = imageOptions[currentIndex];
                imageSelector.dispatchEvent(new Event('change'));
                drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            }
        });

    </script>
</body>

</html>